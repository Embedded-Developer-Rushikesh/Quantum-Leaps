//$file${AO::../Quantum_Leaps::Led_Control.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//
// Model: Led_Control_Active_obj.qm
// File:  ${AO::../Quantum_Leaps::Led_Control.c}
//
// This code has been generated by QM 6.1.1 <www.state-machine.com/qm>.
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// SPDX-License-Identifier: GPL-3.0-or-later
//
// This generated code is open source software: you can redistribute it under
// the terms of the GNU General Public License as published by the Free
// Software Foundation.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
// more details.
//
// NOTE:
// Alternatively, this generated code may be distributed under the terms
// of Quantum Leaps commercial licenses, which expressly supersede the GNU
// General Public License and are specifically designed for licensees
// interested in retaining the proprietary status of their code.
//
// Contact information:
// <www.state-machine.com/licensing>
// <info@state-machine.com>
//
//$endhead${AO::../Quantum_Leaps::Led_Control.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#include"Led_Control.h"
bool btn_pad_value=false;
uint16_t LED_DIM=50;
uint16_t LED_MEDIUM=150;
uint16_t LED_FULL=150;
uint16_t  LED_OFF=0;


//$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
// Check for the minimum required QP version
#if (QP_VERSION < 730U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpc version 7.3.0 or higher required
#endif
//$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$define${AO::ctor_Led_Control} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${AO::ctor_Led_Control} ....................................................
void ctor_Led_Control(void) {
         Led_Contol * const me = &Led_Contol_obj;
        QActive_ctor(&me->super, Q_STATE_CAST(&Led_Contol_initial));
        QTimeEvt_ctorX(&me->timeEvt, &me->super, TIMEOUT_SIG, 0U);
}
//$enddef${AO::ctor_Led_Control} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//$define${AO::Led_Contol} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
extern TIM_HandleTypeDef htim2;
//${AO::Led_Contol} ..........................................................
Led_Contol  Led_Contol_obj;

//${AO::Led_Contol::SM} ......................................................
QState Led_Contol_initial(Led_Contol * const me, void const * const par) {
    //${AO::Led_Contol::SM::initial}
    QTimeEvt_armX(&me->timeEvt, BSP_TICKS_PER_SEC/2, BSP_TICKS_PER_SEC/2);
    return Q_TRAN(&Led_Contol_off);
}

//${AO::Led_Contol::SM::off} .................................................
QState Led_Contol_off(Led_Contol * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${AO::Led_Contol::SM::off}
        case Q_ENTRY_SIG: {
            if(btn_pad_value==false){
            Led_off();
            }
            status_ = Q_HANDLED();
            break;
        }
        //${AO::Led_Contol::SM::off::TIMEOUT}
        case TIMEOUT_SIG: {
            status_ = Q_TRAN(&Led_Contol_On);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

//${AO::Led_Contol::SM::On} ..................................................
QState Led_Contol_On(Led_Contol * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${AO::Led_Contol::SM::On}
        case Q_ENTRY_SIG: {
            if(btn_pad_value==false){
            Led_On();
            }
            status_ = Q_HANDLED();
            break;
        }
        //${AO::Led_Contol::SM::On::TIMEOUT}
        case TIMEOUT_SIG: {
            status_ = Q_TRAN(&Led_Contol_off);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
//$enddef${AO::Led_Contol} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//$define${AO::super_Led_Control} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${AO::super_Led_Control} ...................................................
QActive * const super_Led_Control =&Led_Contol_obj.super;
//$enddef${AO::super_Led_Control} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//$define${AO::LED_Intencity_Control} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${AO::LED_Intencity_Control} ...............................................
void LED_Intencity_Control(uint16_t duty_uint16_t) {
      __HAL_TIM_SET_COMPARE(&htim2,TIM_CHANNEL_1,duty_uint16_t);
}
//$enddef${AO::LED_Intencity_Control} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//$define${AO::Led_On} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${AO::Led_On} ..............................................................
void Led_On(void) {
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_SET);
}
//$enddef${AO::Led_On} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//$define${AO::Led_off} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${AO::Led_off} .............................................................
void Led_off(void) {
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_RESET);
}
//$enddef${AO::Led_off} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//$define${AO::button} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${AO::button} ..............................................................
button button_obj;

//${AO::button::SM} ..........................................................
QState button_initial(button * const me, void const * const par) {
    //${AO::button::SM::initial}
     QTimeEvt_armX(&me->timeEvt, BSP_TICKS_PER_SEC/2, BSP_TICKS_PER_SEC/2);
    LED_Intencity_Control(LED_DIM);
    return Q_TRAN(&button_DIM);
}

//${AO::button::SM::button} ..................................................
QState button_button(button * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

//${AO::button::SM::button::DIM} .............................................
QState button_DIM(button * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${AO::button::SM::button::DIM::TIMEOUT}
        case TIMEOUT_SIG: {
             btn_pad_value=HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_13);
            if(btn_pad_value)
            {
            LED_Intencity_Control(LED_MEDIUM);
            }
            status_ = Q_TRAN(&button_MIDIUM);
            break;
        }
        default: {
            status_ = Q_SUPER(&button_button);
            break;
        }
    }
    return status_;
}

//${AO::button::SM::button::MIDIUM} ..........................................
QState button_MIDIUM(button * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${AO::button::SM::button::MIDIUM::TIMEOUT}
        case TIMEOUT_SIG: {
             btn_pad_value=HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_13);
            if(btn_pad_value)
            {
            LED_Intencity_Control(LED_FULL);
            }
            status_ = Q_TRAN(&button_FULL);
            break;
        }
        default: {
            status_ = Q_SUPER(&button_button);
            break;
        }
    }
    return status_;
}

//${AO::button::SM::button::FULL} ............................................
QState button_FULL(button * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${AO::button::SM::button::FULL::TIMEOUT}
        case TIMEOUT_SIG: {
             btn_pad_value=HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_13);
            if(btn_pad_value)
            {
            LED_Intencity_Control(LED_DIM);
            }
            status_ = Q_TRAN(&button_DIM);
            break;
        }
        default: {
            status_ = Q_SUPER(&button_button);
            break;
        }
    }
    return status_;
}
//$enddef${AO::button} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//$define${AO::button_ctor} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${AO::button_ctor} .........................................................
void button_ctor(void) {
      button * const me = &button_obj;
       QActive_ctor(&me->super, Q_STATE_CAST(&button_initial));
      QTimeEvt_ctorX(&me->timeEvt, &me->super, TIMEOUT_SIG, 0U);
       //QActive_armX(&me->super,0,BSP_TICKS_PER_SEC/2, BSP_TICKS_PER_SEC/2);
}
//$enddef${AO::button_ctor} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//$define${AO::super_button} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${AO::super_button} ........................................................
QActive * const super_button =&button_obj.super;
//$enddef${AO::super_button} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
